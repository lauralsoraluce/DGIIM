# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,by 0.02)
# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,by = 0.02)
length = length(x)
# a. Put names to the elements of x
names(x)<-paste("x_",1:length)
# b. Mean and standard deviation of x
mx<- mean(x)
sx<-sd(x)
# c. Find how many elements of x are above mx in more than two standard deviations
elements<-x[x>mx+2*sx]
print(elements)
# Replace them with NA
x[x > mx + 2 * sx] <- NA
# d. Compute again
new_mx <- mean(x, na.rm = TRUE)
new_varx <- var(x, na.rm = TRUE)
print(new_mx)
print(new_varx)
#Exercise 2
a<- -2
b<- 2
n<- 1000
h<- (b-a)/n
values<- seq(a,b,length.out = n+1)
f_x<-(x<(-1))*(1) + (-1<=x & x<0)*(log(x^2)) + (0<=x & x<1)*(log(x^2 + 1)) + (x>=1)*(2)
f_x
f_x[is.nan(f_x)]<-0
f_x
# Exercise 3
set.seed(1)
x<-rnorm(100,mean=160,sd=10)
# a. Compute the first and last quartiles using the function quantile.
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
# b. Create a factor with 3 levels, encoding the values in x
# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,by = 0.02)
length = length(x)
# a. Put names to the elements of x
names(x)<-paste("x_",1:length)
names
# b. Mean and standard deviation of x
mx<- mean(x)
sx<-sd(x)
# c. Find how many elements of x are above mx in more than two standard deviations
elements<-x[x>mx+2*sx]
print(elements)
# Replace them with NA
x[x > mx + 2 * sx] <- NA
# d. Compute again
new_mx <- mean(x, na.rm = TRUE)
new_varx <- var(x, na.rm = TRUE)
print(new_mx)
print(new_varx)
#Exercise 2
a<- -2
b<- 2
n<- 1000
h<- (b-a)/n
values<- seq(a,b,length.out = n+1)
f_x<-(x<(-1))*(1) + (-1<=x & x<0)*(log(x^2)) + (0<=x & x<1)*(log(x^2 + 1)) + (x>=1)*(2)
f_x
f_x[is.nan(f_x)]<-0
f_x
# Exercise 3
set.seed(1)
x<-rnorm(100,mean=160,sd=10)
# a. Compute the first and last quartiles using the function quantile.
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
# b. Create a factor with 3 levels, encoding the values in x
# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,by = 0.02)
length = length(x)
# a. Put names to the elements of x
names(x)<-paste("x_",1:length)
names(x)
# b. Mean and standard deviation of x
mx<- mean(x)
sx<-sd(x)
# c. Find how many elements of x are above mx in more than two standard deviations
elements<-x[x>mx+2*sx]
print(elements)
# Replace them with NA
x[x > mx + 2 * sx] <- NA
# d. Compute again
new_mx <- mean(x, na.rm = TRUE)
new_varx <- var(x, na.rm = TRUE)
print(new_mx)
print(new_varx)
#Exercise 2
a<- -2
b<- 2
n<- 1000
h<- (b-a)/n
values<- seq(a,b,length.out = n+1)
f_x<-(x<(-1))*(1) + (-1<=x & x<0)*(log(x^2)) + (0<=x & x<1)*(log(x^2 + 1)) + (x>=1)*(2)
f_x
f_x[is.nan(f_x)]<-0
f_x
# Exercise 3
set.seed(1)
x<-rnorm(100,mean=160,sd=10)
# a. Compute the first and last quartiles using the function quantile.
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
# b. Create a factor with 3 levels, encoding the values in x
# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,length.out = 50)
length = length(x)
# a. Put names to the elements of x
names(x)<-paste("x_",1:length)
names(x)
# b. Mean and standard deviation of x
mx<- mean(x)
sx<-sd(x)
# c. Find how many elements of x are above mx in more than two standard deviations
elements<-x[x>mx+2*sx]
print(elements)
# Replace them with NA
x[x > mx + 2 * sx] <- NA
# d. Compute again
new_mx <- mean(x, na.rm = TRUE)
new_varx <- var(x, na.rm = TRUE)
print(new_mx)
print(new_varx)
#Exercise 2
a<- -2
b<- 2
n<- 1000
h<- (b-a)/n
values<- seq(a,b,length.out = n+1)
f_x<-(x<(-1))*(1) + (-1<=x & x<0)*(log(x^2)) + (0<=x & x<1)*(log(x^2 + 1)) + (x>=1)*(2)
f_x
f_x[is.nan(f_x)]<-0
f_x
# Exercise 3
set.seed(1)
x<-rnorm(100,mean=160,sd=10)
# a. Compute the first and last quartiles using the function quantile.
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
# b. Create a factor with 3 levels, encoding the values in x
# Exercise 1:
# Create a vector with name x with a sequence of 50 equally-spaced values between 0 and 1.
x<-seq(0,1,length.out = 50)
length = length(x)
# a. Put names to the elements of x
names(x)<-paste("x_",1:length)
names(x)
# b. Mean and standard deviation of x
mx<- mean(x)
sx<-sd(x)
# c. Find how many elements of x are above mx in more than two standard deviations
elements<-x[x>mx+2*sx]
print(elements)
# Replace them with NA
x[x > mx + 2 * sx] <- NA
# d. Compute again
new_mx <- mean(x, na.rm = TRUE)
new_varx <- var(x, na.rm = TRUE)
print(new_mx)
print(new_varx)
#Exercise 2
a<- -2
b<- 2
n<- 1000
h<- (b-a)/n
values<- seq(a,b,length.out = n+1)
f_x<-(x<(-1))*(1) + (-1<=x & x<0)*(log(x^2)) + (0<=x & x<1)*(log(x^2 + 1)) + (x>=1)*(2)
f_x
f_x[is.nan(f_x)]<-0
f_x
# Exercise 3
set.seed(1)
x<-rnorm(100, mean=160, sd=10)
# a. Compute the first and last quartiles using the function quantile.
?quantile
quartiles <- quantile(x, probs = c(0.25, 0.75))
quartil_1 <- quartiles[1]
quartil_3 <- quartiles[2]
# b. Create a factor with 3 levels, encoding the values in x
x_factor <- cut(x, breaks = c(-Inf, quartil_1, quartil_3, Inf), labels = c("low", "medium", "high"))
# c. Generate a second vector y
y<-x-100+rnorm(100, mean = 0, sd = 1)
y
# d. Compute a summary of y for each level of the factor
summary_by_factor <- tapply(y, x_factor, summary)
print(summary_by_factor)
## Part 2: Linear regression, overdetermined systems and least squares
### Exercise 1
##### Execute the code below to examine the data and determine the number of observations (n). Refer to the documentation to learn more about this data set.
```{r}
head(cars)
data(cars)
cars[1,1]<-0
datasets::cars[1,1]
library(boot)
search()
data(coal,package="boot")
names(cars)
mean(cars$speed)
attach(cars)
mean(speed)
search()
mean(speed) # Now it does work
detach(cars )#After we're done using it
compute_mean<-function(x)
{
return(mean(x, na.rm = TRUE), sum(is.na(x)))
}
compute_mean2<-function(xi, ni)
{
return(mean(xi*ni), sum(ni))
}
return(list(mean(x, na.rm = TRUE), sum(is.na(x))))
compute_mean<-function(x)
{
return(list(mean(x, na.rm = TRUE), sum(is.na(x))))
}
# Compute_mean2
compute_mean2<-function(xi, ni)
{
sample_size <- sum(ni)
return(list(sum(xi*ni)/sample_size, sample_size))
}
compute_mean(c(1:10,NA))
compute_mean2(1:10,rep(2,10))
# Compute_mean2
compute_mean2<-function(xi, ni)
{
sample_size <- sum(ni)
return(list(sum(xi*ni)/sample_size, sample_size))
}
compute_mean2(1:10,rep(2,10))
mysqrt<-function(x){
if (!is.numeric(x)){
print("The vector isn't numeric")
}
if (x<=0){
print("Not aall the numbers are positive")
}
return (sqrt(x))
}
mysqrt(x)
x<-c(1,2,6)
mysqrt(x)
mysqrt<-function(x){
if (!is.numeric(x)){
print("The vector isn't numeric")
}
if (x<0 | x=0){
mysqrt<-function(x){
if (!is.numeric(x)){
print("The vector isn't numeric")
}
if (x<0 | x==0){
print("Not all the numbers are positive")
}
return (sqrt(x))
}
x<-c(1,2,6)
mysqrt(x)
if (any(x<=0)){
print("Not all the numbers are positive")
}
mysqrt<-function(x){
if (!is.numeric(x)){
print("The vector isn't numeric")
}
if (any(x<=0)){
print("Not all the numbers are positive")
}
return (sqrt(x))
}
x<-c(1,2,6)
mysqrt(x)
x<-c(1,2,-6)
mysqrt(x)
mysqrt<-function(x){
if (!is.numeric(x)){
print("The vector isn't numeric")
}
else if (any(x<=0)){
print("Not all the numbers are positive")
}
else {return (sqrt(x))}
}
x<-c(1,2,-6)
mysqrt(x)
mysqrt<-function(x){
if (is.numeric(x) && x>0) sqrt(x) else
cat("x should be numeric and positive", "\n")
}
mysqrt(1:5)
mysqrt<-function(x){
if (is.numeric(x) && min(x)>0) sqrt(x) else
cat("x should be numeric and positive", "\n")
}
mysqrt(1:5)
mysqrt<-function(x){
if (is.numeric(x) && all(x)>0) sqrt(x) else
cat("x should be numeric and positive", "\n")
}
mysqrt(1:5)
mean.options <- function(x, mean.type = "arithmetic") {
# Check if x is a numeric vector
if (!is.numeric(x)) {
stop("x must be numeric")
}
arithmetic_mean <- function(x) mean(x, na.rm = TRUE)
harmonic_mean <- function(x) {
if (all(x>0)) {
return(length(x) / sum(1 / x, na.rm = TRUE))
}
else {
return(NA)
}
}
geometric_mean <- function(x) {
if (all(x>0)){
return(exp(mean(log(x), na.rm = TRUE)))
}
else {
return(NA)
}
}
result <- switch(mean.type,
"arithmetic" = list(arithmetic = arithmetic_mean(x)),
"harmonic" = list(harmonic = harmonic_mean(x)),
"geometric" = list(geometric = geometric_mean(x)),
"all" = list(
arithmetic = arithmetic_mean(x),
harmonic = harmonic_mean(x),
geometric = geometric_mean(x)
),
stop("Invalid mean.type")
)
return(result)
}
x<-c(1,2,3,4,5)
mean.options(x, "all")
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-numeric(n)
x[1]<-x1
for (i in 1:n-1){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
xn(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-x1
for (i in 2:n-1){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
x(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-x1
for (i in 1:n-1){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
x(10,1,0.9)
xn(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-numeric(n)
x[1]<-x1
for (i in 1:n-1){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
xn(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-numeric(n)
x[1]<-x1
for (i in 1:(n-1)){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
xn(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x<-x1
for (i in 1:(n-1)){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
xn(10,1,0.9)
xn <- function(n, r, x1){
if (!is.numeric(n) || n<=0){
stop('n must be numeric and positive')
}
x[1]<-x1
for (i in 1:(n-1)){
x[i+1]<-r*x[i]*(1-x[i])
}
return (x)
}
xn(10,1,0.9)
xn.d <- function(d,r,x1) {
if (!is.numeric(d) || d<=0){
stop('d must be numeric and positive')
}
x[1]<-x1
x[2]<-r*x[1]*(1-x[1])
i<-2
while (abs(x[i]-x[i-1])>d){
x[i+1]<-r*x[i]*(1-x[i])
i<-i+1
}
return x
xn.d <- function(d,r,x1) {
if (!is.numeric(d) || d<=0){
stop('d must be numeric and positive')
}
x[1]<-x1
x[2]<-r*x[1]*(1-x[1])
i<-2
while (abs(x[i]-x[i-1])>d){
x[i+1]<-r*x[i]*(1-x[i])
i<-i+1
}
return (x)
}
xn.d(5e-3, 1,0.9)
xn.d(5e-3, 1,0.9)
df<-data.frame(matrix(c(1:2,2.5,3,4,6),2,3))
lapply(df,sd)
A<-cbind(1:4,seq(0,1,length.out=4),(1:4)^2)
apply(A,1,median)
apply(A,2,var)
apply(A,c(1,2),sqrt)
data("airquality")
quartiles<-apply(airquality[,1:3],2,quantile)
quartiles<-apply(airquality[,1:3],2,quantile, na.rm=TRUE)
quartiles
quartiles<-apply(airquality[,1],2,quantile, na.rm=TRUE)
quartiles<-apply(airquality[,1:3],2,quantile, na.rm=TRUE)
quartiles
quartiles<-apply(airquality[,1:3],quantile, na.rm=TRUE)
quartiles<-apply(airquality[,1:3],2,quantile, na.rm=TRUE)
quartiles2<-lapply(airquality[,1:3],quantile)
quartiles2<-lapply(airquality[,1:3],quantile,na.rm=TRUE)
quartiles2
probs<-c(0.25,0.5,0.75)
quartiles2<-lapply(airquality[,1:3],quantile,probs,na.rm=TRUE)
quartiles2
quartiles<-apply(airquality[,1:3],2,quantile, probs,na.rm=TRUE)
quartiles
quartiles2<-lapply(airquality[,1:3],quantile,probs,na.rm=TRUE)
quartiles2
data("airquality")
probs<-c(0.25,0.5,0.75)
quartiles<-apply(airquality[,1:3],2,quantile, probs,na.rm=TRUE)
quartiles
quartiles2<-lapply(airquality[,1:3],quantile,probs,na.rm=TRUE)
quartiles2
data("Orange")
probs<-c(0.25,0.5,0.75)
quartiles_o<-apply(orange[,"circumference"],2,quantile,probs,na.rm=TRUE)
quartiles_o<-apply(orange[,"circumference"],2,quantile,probs,na.rm=TRUE)
quartiles_o<-apply(Orange[,"circumference"],2,quantile,probs,na.rm=TRUE)
aggregate(Orange$circumference, by=list(Orange$Tree),quantile,probs,na.rm=TRUE)
library(knitr)
knitr('knitr-minimal.tex')
knit('knitr-minimal.tex')
knit('knitr-minimal.tex')
setwd("~/Escritorio/DGIIM/QUINTO/COMPUTATIONAL")
knit('knitr-minimal.tex')
knit('knitr-minimal.Rnw')
knit('knitr-minimal.Rnw')
tools::text2pdf('knitr-minimal.tex')
tools::tex2pdf('knitr-minimal.tex')
tools::texi2pdf('knitr-minimal.tex')
install.packages("tinytex")
tinytex::install_tinytex()
setwd("~/Escritorio/DGIIM/QUINTO/COMPUTATIONAL")
tinytex::latexmk("knitr-minimal.tex")
setwd("~/Escritorio/DGIIM/QUINTO/COMPUTATIONAL/training_exercises")
