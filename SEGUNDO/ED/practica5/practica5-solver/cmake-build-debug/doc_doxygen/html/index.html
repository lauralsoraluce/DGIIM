<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica 4. Juego de las Letras - Solver: María Cribillés y Laura Lázaro</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Práctica 4. Juego de las Letras - Solver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">María Cribillés y Laura Lázaro </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Introducción</h1>
<div class="image">
<img src="cifrasyletras.jpg" alt=""/>
</div>
<p>Esta es la segunda de varias prácticas para crear el juego de cifras y letras. Nos volvemos a centrar en el juego de las letras, el cual ya hemos podido resolver.</p>
<p>El objetivo del juego es formar la mejor palabra posible (depende de si se juega por longitud o por puntuación). Se extraen varias letras al azar, de las cuales algunas (las más comunes) tienen más probabilidades de salir, pues están más repetidas. Con esas letras deberemos formar la palabra más larga o de mayor puntuación.</p>
<p>En esta práctica, hemos utilizado los TDAs creados en la práctica anterior y hemos creado una clase <a class="el" href="classSolver.html">Solver</a> con la cual hemos sido capaces de resolver el juego de las letras de manera eficiente. En concreto, vamos a usar el TDA <a class="el" href="classDictionary.html">Dictionary</a> para saber el conjunto de palabras que consideramos soluciones posibles de nuestro juego; el TDA <a class="el" href="classLettersSet.html" title="TDA LettersSet.">LettersSet</a> para saber cuántas letras de cada tipo disponemos y la puntuación que nos da cada una al usarla en la solución; y el TDA <a class="el" href="classLettersBag.html" title="TDA LettersBag.">LettersBag</a> (que por debajo utiliza el TDA <a class="el" href="classBag.html" title="TDA abstracto Bolsa.">Bag</a>) con las letras concretas con las que jugaremos una partida. Nuestro <a class="el" href="classSolver.html">Solver</a> tiene que ofrecer la mejor solución para una partida y modo de juego determinado. Como esta solución no tiene por qué ser única (puede haber varias palabras con una misma puntuación o longitud), necesitamos poder ofrecer un conjunto de palabras con una misma puntuación.</p>
<p>Ejemplo del juego de las letras: </p><pre class="fragment">   o r s a p e t
</pre><p>La palabra que usaría todas las letras sería: esparto</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Ejecutables</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
partida_letras.cpp</h2>
<p>Este ejecutable está asociado al <a class="el" href="solver_8cpp.html" title="Archivo de implementación del TDA Solver.">solver.cpp</a>. Es un pequeño programa que recibe cuatro argumentos:</p>
<ol type="1">
<li>Ruta al archivo que contiene las letras y la puntuación</li>
<li>Ruta al archivo que contiene el diccionario</li>
<li>Modo de juego (L para modo de juego con la longitud y P para modo de juego con la puntuación)</li>
<li>Cantidad de letras para la partida</li>
</ol>
<p>Explicación de los pasos que seguimos en el ejecutable:</p><ol type="1">
<li>Comprobamos que el número de argumentos dados sea el correcto, en este caso debe haber 4 argumentos.</li>
<li>A partir de los archivos del diccionario y de las letras, creamos el diccionario y el <a class="el" href="classLettersSet.html" title="TDA LettersSet.">LettersSet</a> para la partida. Los leemos mediante el flujo ifstream.</li>
<li>A partir del lettersSet, creamos la bolsa de la que se irán sacando las letras.</li>
<li>Creamos el solver con el diccionario y el lettersSet anteriores.</li>
<li>Establecemos el modo de juego y sacamos un número n de letras aleatorias de la bolsa para jugar el turno.</li>
<li>Mostramos las letras disponibles para formar palabras en el turno.</li>
<li>Obtenemos las mejores palabras posibles en el turno y las mostramos.</li>
</ol>
<p>El resultado de ejecutar este programa es</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Ejemplo de ejecucción:</h3>
<h4><a class="anchor" id="autotoc_md4"></a>
Modo de juego por longitud:</h4>
<p>Con los siguientes argumentos:data/letras.txt data/diccionario.txt L 9</p>
<p>LETRAS DISPONIBLES: S O A R D N N I B</p>
<p>SOLUCIONES: andrino binador brandis disonar nardino sabidor sordina</p>
<p>PUNTUACION: 7</p>
<h4><a class="anchor" id="autotoc_md5"></a>
Modo de juego por puntuación:</h4>
<p>Con los siguientes argumentos: data/letras.txt data/diccionario.txt P 9</p>
<p>LETRAS DISPONIBLES: O R C D A A O O M</p>
<p>SOLUCIONES: acomodar acromado morocada</p>
<p>PUNTUACION: 13</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Complejidad computacional O-grande</h1>
<p>El constructor sin parámetros del <a class="el" href="classSolver.html">Solver</a>, tiene complejidad O(1), pues simplemente llama a los constructores sin parámetros del Diccionario y del LetterSet. Ambos llaman al clear del set y del map respectivamente. En este caso, ambos clear tienen complejidad O(1), pues no tienen que recorrer las estructuras, pues ambas están vacías.</p>
<p>El constructor con parámetros del <a class="el" href="classSolver.html">Solver</a> tiene complejidad O(n) ya que llama al operator= del <a class="el" href="classLettersSet.html" title="TDA LettersSet.">LettersSet</a> y del <a class="el" href="classDictionary.html">Dictionary</a>, que ambos llaman respectivamente al operator= del set y del map. Estos dos métodos tienen complejidad O(n) (en el primer caso O(letters.size()) y en el segundo O(words.size())). Por lo tanto el constructor con parámetros tiene O(2n) que es lo mismo que O(n).</p>
<p>El método privado getSolsLength tiene complejidad O(n^3): </p><pre class="fragment">bucle for interior (depende de j):

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(copy.size()) = O(n)

    O(Cu(n)) = O(1) condicion + O(1) bool + O(1) igualación + O(1) pop_back = O(4) = O(1)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(1)+O(1)+O(1)] = O(n)


bucle for medio interior (depende de i):

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(words.at(k).size()) = O(n)

    O(Cu(n)) = O(n)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(n)+O(1)+O(1)] = O(n*n) = O(n^2)


bucle for medio exterior (depende de k):

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(words.size()) = O(n)

    O(Cu(n)) = O(n^2)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(n^2)+O(1)+O(1)] = O(n*n*n) = O(n^3)


bucle for exterior:

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(size) = O(n)

    O(Cu(n)) = O(n*n*n) = O(n^3)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(n^3)+O(1)+O(1)] = O(n*n*n*n) = O(n^4)


wordsOfLength es un método del TDA Dictionary usado en el bucle for exterior del método getSolsLength y tiene una complejidad de O(words.size()) = O(n).
</pre><p>El método privado getSolsScore tiene complejidad O(n^3): </p><pre class="fragment">bucle for interior:

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(copy.size()) = O(n)

    O(Cu(n)) = O(1) condicion + O(1) bool + O(1) igualación + O(1) pop_back = O(4) = O(1)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(1)+O(1)+O(1)] = O(n)


bucle for medio:

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O((*it).size()) = O(n)

    O(Cu(n)) = O(n)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(n)+O(1)+O(1)] = O(n*n) = O(n^2)


bucle for exterior:

    O(Ini(n)) = O(1)

    O(Con(n)) = O(1)

    O(Ite(n)) = O(dict.size()) = O(n)

    O(Cu(n)) = O(n*n) = O(n^2)

    O(Inc(n)) = O(1)


    O(1)+O(1)+O(n)*[O(n^2)+O(1)+O(1)] = O(n*n*n) = O(n^3)


getScore es un método del TDA LettersSet usado en el bucle for exterior del método getSolsScore y tiene una complejidad de O(n^2), pues se trata de dos bucles for anidados, el interior con un cuerpo de O(1) y n iteraciones, y el exterior con un cuerpo de O(words.length()) = O(n) y n iteraciones. 
</pre><p>El método público getSolutions tiene una complejidad O(n^3): </p><pre class="fragment">Tanto el if como el else tienen condición O(1) y cuerpo O(n^3). 
</pre><p>En el archivo partida_letras.cpp usamos varios métodos de los TDAs de la práctica 4: </p><pre class="fragment">El exists del Dictionary tiene complejidad O(log(n)), pues llama al find del set words, que tiene O(log(n)).

El insert del Dictionary tiene complejidad O(log(n)), pues llama al insert del set words, que tiene O(log(n)).

El constructor con parámetros del LettersBag tiene complejidad O(n^2), pues se trata de dos bucles for anidados. El interior con cuerpo O(1) (ya que llama al insertLetter del LettersBag, que a su vez llama al add del Bag, que a su vez llama al push_back del vector, que es O(1)) y (*it).second.repetitions iteraciones, es decir, n iteraciones; y el segundo con cuerpo O(n) y lettersSet.size() iteraciones, es decir, n iteraciones. 

El extractLetters del LettersBag tiene complejidad O(n) pues se trata de un bucle for con num iteraciones (es decir, n iteraciones) y cuerpo O(1) (pues llama al extractLetter del Bag, que a su vez llama al get del Bag, que es O(1)).
</pre> </div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
